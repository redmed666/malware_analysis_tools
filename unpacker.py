from qiling import *
from qiling.const import *
from qiling.os.windows.fncc import *
from qiling.os.const import *
from qiling.os.windows.const import *
import argparse
import sys
import pefile
import os
import struct
from unicorn import *
from unicorn.x86_const import *
from capstone import *

VA_ADDRS = []
EXE_ADDRS_REW = {}
EXE_BASE = 0x0
EXE_END = 0x0
EXE_SIZE = 0x0
IMPORTS = {}
OUTPUT = ""


def fix_iat(pe):
    pass


def reconstruct_pe(pe, oep):
    for i in range(0, len(pe.sections)):
        pe.sections[i].PointerToRawData = pe.sections[i].VirtualAddress
        pe.sections[i].SizeOfRawData = pe.sections[i].Misc_VirtualSize
        pe.OPTIONAL_HEADER.AddressOfEntryPoint = (oep - EXE_BASE)
    fix_iat(pe)


def construct_r2_script(procdump):
    global IMPORTS, EXE_BASE
    r2_script = ""
    for dll in IMPORTS:
        for proc in IMPORTS[dll]:
            addr_found = procdump.find(struct.pack("<I", proc[0]))
            addr_flag = addr_found + EXE_BASE
            new_flag = "f %s @ 0x%08x\n" % (proc[1], addr_flag)
            r2_script += new_flag
    return r2_script


@winapi(cc=STDCALL, params={
    "lpAddress": POINTER,
    "dwSize": SIZE_T,
    "flAllocationType": DWORD,
    "flProtect": DWORD
})
def hook_VirtualAlloc(ql, address, params):
    global VA_ADDRS
    dwSize = params["dwSize"]
    addr = ql.os.heap.mem_alloc(dwSize)
    VA_ADDRS.append([addr, addr + dwSize])
    return addr


@winapi(cc=STDCALL, params={
    "hModule": POINTER,
    "lpProcName": POINTER
})
def hook_GetProcAddress(ql, address, params):
    global IMPORTS
    if params["lpProcName"] > MAXUSHORT:
        # Look up by name
        params["lpProcName"] = read_cstring(ql, params["lpProcName"])
        lpProcName = bytes(params["lpProcName"], "ascii")
    else:
        # Look up by ordinal
        lpProcName = params["lpProcName"]
    # TODO fix for gandcrab
    if params["lpProcName"] == "RtlComputeCrc32":
        return 0

    # Check if dll is loaded
    try:
        dll_name = [key for key, value in ql.loader.dlls.items()
                    if value == params['hModule']][0]
    except IndexError as ie:
        ql.nprint('[!] Failed to import function "%s" with handle 0x%X' %
                  (lpProcName, params['hModule']))
        return 0

    # Handle case where module is self
    if dll_name == os.path.basename(ql.loader.path):
        for addr, export in ql.loader.export_symbols.items():
            if export['name'] == lpProcName:
                if dll_name in IMPORTS.keys():
                    IMPORTS[dll_name].append([addr, lpProcName])
                else:
                    IMPORTS[dll_name] = []
                    IMPORTS[dll_name].append([addr, lpProcName])
                return addr

    if lpProcName in ql.loader.import_address_table[dll_name]:
        addr = ql.loader.import_address_table[dll_name][lpProcName]
        if dll_name in IMPORTS.keys():
            IMPORTS[dll_name].append([addr, lpProcName])
        else:
            IMPORTS[dll_name] = []
            IMPORTS[dll_name].append([addr, lpProcName])
        return addr

    return 0


def hook_exec(ql, address, size):
    global EXE_ADDRS_REW, VA_ADDRS, EXE_BASE, EXE_SIZE, OUTPUT, EXE_END
    if ql.loader.entry_point == address:
        for start, end, _, path in ql.mem.map_info:
            if "[PE]" in path:
                EXE_BASE = start
                EXE_SIZE = end - start
                EXE_END = end
                break
        print("[*] EXE_BASE = %08x, EXE_SIZE = %08x, EXE_END = %08x" %
              (EXE_BASE, EXE_SIZE, EXE_END))

    elif address in EXE_ADDRS_REW:
        print("[*] Dumping new exe")
        allocd = ql.mem.read(EXE_BASE, EXE_SIZE)
        new_pe = pefile.PE(data=allocd)
        reconstruct_pe(new_pe, address)
        filename = OUTPUT + "_unpacked.exe"
        new_pe.write(filename)
        new_pe.close()
        r2_script = construct_r2_script(allocd)
        r2_filename = filename + ".r2"
        with open(r2_filename, "w+") as f:
            f.write(r2_script)
        f.close()
        sys.exit()

    for addr in VA_ADDRS:
        if address >= addr[0] and address <= addr[1]:
            print("[*] Executing allocated mem")
            VA_ADDRS.pop(VA_ADDRS.index(addr))
            allocd = ql.mem.read(addr[0], addr[1] - addr[0])
            new_bin_filename = "mem_alloc_%08x.bin" % addr[0]  # base address
            with open(new_bin_filename, "wb+") as f:
                f.write(allocd)
            f.close()


def hook_write(ql, access, address, size, value):
    global EXE_ADDRS_REW, EXE_BASE, EXE_END
    if address >= EXE_BASE and address <= EXE_END:
        EXE_ADDRS_REW[address] = 1


md = Cs(CS_ARCH_X86, CS_MODE_64)


def print_asm(ql, address, size):
    buf = ql.mem.read(address, size)
    for i in md.disasm(buf, address):
        print(":: 0x%x:\t%s\t%s" % (i.address, i.mnemonic, i.op_str))


def sandbox(path, rootfs):
    global OUTPUT
    filename = os.path.basename(path)
    output_path = os.path.dirname(path)
    exe = filename.split(".")[0]
    OUTPUT = output_path + os.path.sep + exe

    ql = Qiling([path], rootfs)
    ql.hook_code(hook_exec)
#    ql.hook_code(print_asm)
    ql.hook_mem_write(hook_write)
    ql.set_api("VirtualAlloc", hook_VirtualAlloc)
    ql.set_api("GetProcAddress", hook_GetProcAddress)
    ql.run()


if __name__ == "__main__":
    argp = argparse.ArgumentParser()
    argp.add_argument("--rootfs", help="Path to rootfs", required=True)
    argp.add_argument("--file", help="Path to executable", required=True)
    args = argp.parse_args()
    sandbox(args.file, args.rootfs)
