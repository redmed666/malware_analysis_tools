
import r2pipe
import sys
import operator
import collections
import argparse
import texttable
from itertools import zip_longest

# pre analyze stuffs => statistics about the binary like most called functions, calls from functions, 
# harder stuffs => hash, json database, comparison between function and functions in db, scoring, ... 

def get_refs_to_fct(a):
    refs_to = (r2p.cmd('axq~'+str(hex(a['offset']).strip('0x')))).split('\n')
    result = []
    if refs_to != ['']:
        for xref in refs_to:
            result.append(xref.split(' ')[2])
        result = list(set(result))
    return result

def get_refs_from_fct(a):
    refs_from = (r2p.cmd('pif@'+str(a['offset'])+'~call')).split('\n')
    result = []
    for ref in refs_from:
        result.append(ref.strip('call '))
    result = list(set(result))
    return result

def order_fct_dic(fct_dic, ordering_value):
    fct_dic_sorted = collections.OrderedDict(sorted(fct_dic.items(), key=lambda x: x[1][ordering_value]))
    return fct_dic_sorted

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Show some stats from the executable passed as argument.')
    parser.add_argument('path', type=str, help='Path to executable')
    parser.add_argument('-o', '--ordering', type=str, help='Ordering value.', choices=['nmb_refs_to', 'nmb_refs_from', 'size'], required=True)

    args = parser.parse_args()
    path_file = args.path
    ordering_value = args.ordering

    r2p = r2pipe.open(path_file)  # open without arguments only for #!pipe
    r2p.cmd('aaa;aac')  # analyze all symbols and calls
  
    fct_dic = {}

    for a in r2p.cmdj('aflj'): # return info of functions in jason
        if a['size'] > 0: # if size of function is > 128 continue
            refs_from = get_refs_from_fct(a)
            refs_to = get_refs_to_fct(a)
            fct_dic[a['name']] = {'refs_from': refs_from, 'refs_to': refs_to, 'nmb_refs_to': len(refs_to), 'size':a['size'], 'nmb_refs_from': len(refs_from)}

    fct_dic_sorted = order_fct_dic(fct_dic, ordering_value)

    tab = texttable.Texttable()
    headings = ['Function name','Number refs to fct','Number refs from fct','Size']
    tab.header(headings)
  
    for function, elements in fct_dic_sorted.items():
        for row in list(zip_longest([str(function)], [str(elements['nmb_refs_to'])], [str(elements['nmb_refs_from'])], [str(elements['size'])])):
            tab.add_row(row)

    s = tab.draw()
    print (s)