from qiling import *
from qiling.const import *
from qiling.os.windows.fncc import *
from qiling.os.const import *
from qiling.os.windows.const import *
import argparse
import sys
import pefile
import os
import struct
from unicorn import *
from unicorn.x86_const import *
from capstone import *
import r2pipe
import re

ARG = 0


def get_refs_fn(r2, addr):
    ref = r2.cmdj("axtj @ {}".format(addr))
    return ref


def get_decompilation_fn(r2, addr):
    dec = r2.cmdj("pdgj @ {}".format(addr))
    return dec


def get_instr_context(r2, addr, nmb_instr=3):
    ctx = r2.cmdj("pdj -{} @ {}".format(nmb_instr, addr))
    return ctx


def get_val_reg(ctx, reg="rcx"):
    for instr in ctx:
        if instr["type"] == "mov" and "val" in instr:
            esil = instr["esil"].split(",")
            # we search for instruction of type
            # 123456,reg,=
            if esil[1] == reg:
                return instr["val"]


def get_args_fn(path, addr_fn):
    r2 = r2pipe.open(path)
    r2.cmd("aa;aac")
    args = []
    refs_fn = get_refs_fn(r2, addr_fn)
    for ref in refs_fn:
        ctx = get_instr_context(r2, ref["from"])
        val = get_val_reg(ctx)
        if val is not None:
            args.append(val)
    r2.quit()
    return args


def print_return(ql):
    global ARG
    rax = ql.reg.read("RAX")
    ql.nprint("{} => {}".format(ARG, rax))
    if rax in ql.loader.import_symbols:
        ql.nprint("{} => {}".format(
            ql.loader.import_symbols[rax], ARG))


def sandbox(path, rootfs, beg_fn, end_fn):
    global ARG
    filename = os.path.basename(path)
    output_path = os.path.dirname(path)
    exe = filename.split(".")[0]
    args = get_args_fn(path, beg_fn)

    ql = Qiling([path], rootfs)
    ql.hook_address(print_return, end_fn-2)
    for arg in args:
        ARG = arg
        ql.reg.write("RCX", arg)
        ql.run(begin=beg_fn, end=end_fn)


if __name__ == "__main__":
    argp = argparse.ArgumentParser()
    argp.add_argument("-r", "--rootfs",
                      help="Path to rootfs", required=True)
    argp.add_argument(
        "-f", "--file", help="Path to executable", required=True)
    argp.add_argument("-b", "--begin",
                      help="Beginning of Function (in hex)", type=lambda x: int(x, 0), required=True)
    argp.add_argument("-e", "--end",
                      help="Ending of Function (return address in hex)", type=lambda x: int(x, 0), required=True)
    args = argp.parse_args()
    sandbox(args.file, args.rootfs, args.begin, args.end)
