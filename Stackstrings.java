//
//@author 
//@category 
//@keybinding shift a
//@menupath File.Run.Stackstrings
//@toolbar

import java.math.BigInteger;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.TreeSet;

import ghidra.app.emulator.EmulatorHelper;
import ghidra.app.script.GhidraScript;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressRange;
import ghidra.program.model.lang.Register;
import ghidra.program.model.listing.CodeUnit;
import ghidra.program.model.listing.Variable;
import ghidra.program.model.symbol.SourceType;
import ghidra.util.exception.CancelledException;

public class Stackstrings extends GhidraScript {

	public static boolean isPureAscii(String v) {
		return Charset.forName("US-ASCII").newEncoder().canEncode(v);
	    // or "ISO-8859-1" for ISO Latin 1
	    // or StandardCharsets.US_ASCII with JDK1.7+
    }
	
	Address getAddress(Integer offset) {
		return currentProgram.getAddressFactory().getDefaultAddressSpace().getAddress(offset);	
	}
	
	Register[] getProgramRegisterList() {
		var pc = currentProgram.getProgramContext();
		return pc.getRegisters();
	}
	
	public String toHex(String arg) {
	    return String.format("%040x", new BigInteger(1, arg.getBytes(/*YOUR_CHARSET?*/)));
	}
	
	HashMap<Address, Address> emulate(EmulatorHelper emuHelper, Address beg, Address end) {
		print("[*] Emulation started\n");
		printf("Beginning: %08x\n", beg.getOffset());
		printf("Ending: %08x\n", end.getOffset());
		emuHelper.writeRegister(emuHelper.getPCRegister(), beg.getOffset());
		List<AddressRange> prevMemRange = new ArrayList<AddressRange>();
		var tableEipMemMod = new HashMap<Address, Address>();
		
		while (monitor.isCancelled() == false) {
			var executionAddr = emuHelper.getExecutionAddress();
			if (executionAddr.getOffset() == end.getOffset()) {
				print("[*] Emulation finished\n");
				return tableEipMemMod;
			}
			
			boolean success;
			try {
				var eip = emuHelper.getExecutionAddress();
				success = emuHelper.step(monitor);
				var memsMod = emuHelper.getTrackedMemoryWriteSet();
				for (var mem : memsMod) {
					if (mem.getAddressSpace().getName().equalsIgnoreCase("ram") == true) {
						var included = false;
						for (var i = 0; i < prevMemRange.size(); i++) {
							var range = prevMemRange.get(i);
							// Test if ranges already in prevMemRange were updated
							if (range.getMinAddress().equals(mem.getMinAddress()) == false && range.getMaxAddress().equals(mem.getMaxAddress()) == true) {
								included = true;
								prevMemRange.set(i, mem);
								tableEipMemMod.put(mem.getMinAddress(), eip);
								break;
							} else if (range.getMinAddress().equals(mem.getMinAddress()) == true && range.getMaxAddress().equals(mem.getMaxAddress()) == false) {
								included = true;
								prevMemRange.set(i, mem);
								// add(0x1) is there to cover the cases where the binary writes more than 1 byte
								// example mov word [ebp + 0x5], 0x41
								// it will move the range and without the add, you will read a null byte
								tableEipMemMod.put(range.getMaxAddress().add(0x1), eip);
								break;
							} else if (range.getMinAddress().equals(mem.getMinAddress()) == true && range.getMaxAddress().equals(mem.getMaxAddress()) == true) {
								included = true;
								break;
							}
						}
						// If there is a new range, adds it to prevMemRange
						if (included == false) {
							prevMemRange.add(mem);
							tableEipMemMod.put(mem.getMinAddress(), eip);
						}
					}
				}
				
				if (success == false) {
					var error = emuHelper.getLastError();
					printf("[!] Error during emulation: %s\n", error);
					return tableEipMemMod;
				}
			} catch (CancelledException e) {
				e.printStackTrace();
				return tableEipMemMod;
			}
		}
		return tableEipMemMod;
	}
		
	@Override
	protected void run() throws Exception {
		var emuHelper = new EmulatorHelper(currentProgram);
		emuHelper.enableMemoryWriteTracking(true);
		emuHelper.writeRegister(emuHelper.getStackPointerRegister(), 0x1000);
		emuHelper.writeRegister("EBP", 0x8000);

		var fnManager = currentProgram.getFunctionManager();
		Address beg;
		Address end;
		try {
			beg = currentSelection.getFirstRange().getMinAddress();
			end = currentSelection.getLastRange().getMaxAddress();
			
		}
		catch (Exception e) {
			printf("[x] Selection is empty. Please, select the instructions to emulate.\n");
			return;
		}
		
		var function = fnManager.getFunctionContaining(beg);
		var fnVars = function.getLocalVariables();
		var mapFnVars = new HashMap<Integer, Variable>();
		
		for(var variable : fnVars) {
			try {
				var stackOffset = variable.getStackOffset();
				mapFnVars.put(stackOffset, variable);				
			} catch (Exception e) {
				printf("[!] Error for variable %s: %s\n", variable.getName(), e.getMessage());
			}
		}
		
		/*
		 * See https://stackoverflow.com/questions/922528/how-to-sort-map-values-by-key-in-java
		 * I wanted to have the memory areas printed from the lowest address to the highest to debug
		 * more easily.
		 */
		var mems = emulate(emuHelper, beg, end);
		Comparator<Address> comparator = (Address a1, Address a2) -> {
			return a1.compareTo(a2);
		};
		var keys = new TreeSet<>(comparator);
		keys.addAll(mems.keySet());
		for (var addr : keys) {
			var decrStr = "";
			var addrInstr = mems.get(addr);
			try {
				decrStr = emuHelper.readNullTerminatedString(addr, 0xffff);
			}
			catch (Exception e) {
				printf("[!] Error: %s\n", e.getMessage());
				continue;
			}
			if(!decrStr.isEmpty()) {				
				printf("%s => %s => %s\n", addrInstr, addr, decrStr);
			}
			if (isPureAscii(decrStr)) {		
				var instruction = currentProgram.getListing().getInstructionAt(addrInstr);
				instruction.setComment(CodeUnit.EOL_COMMENT, decrStr);
				instruction.setComment(CodeUnit.PRE_COMMENT, decrStr);
				// try/catch => dirty. Should check if there are multiple operands and if there is a variable for that offset
				try {
					var toAddr = (int)instruction.getPrimaryReference(0).getToAddress().getOffset(); // cast to int otherwise doesn't work...
					var decrStrName = decrStr.strip().replaceAll(" ", "_");
					var name = "local_" + decrStrName;
					var variable = mapFnVars.get(toAddr);
					variable.setName(name, SourceType.USER_DEFINED);				
				} catch (Exception e) {
					continue;
				}
			}

		}
		emuHelper.dispose();
	}
}
