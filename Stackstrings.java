//
//@author 
//@category 
//@keybinding
//@menupath
//@toolbar

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import ghidra.app.emulator.EmulatorHelper;
import ghidra.app.script.GhidraScript;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressRange;
import ghidra.program.model.lang.Register;
import ghidra.program.model.listing.CodeUnit;
import ghidra.program.model.listing.Variable;
import ghidra.program.model.symbol.SourceType;
import ghidra.util.exception.CancelledException;

public class Stackstrings extends GhidraScript {

	Address getAddress(Integer offset) {
		return currentProgram.getAddressFactory().getDefaultAddressSpace().getAddress(offset);	
	}
	
	Register[] getProgramRegisterList() {
		var pc = currentProgram.getProgramContext();
		return pc.getRegisters();
	}
	
	public String toHex(String arg) {
	    return String.format("%040x", new BigInteger(1, arg.getBytes(/*YOUR_CHARSET?*/)));
	}
	
	HashMap<Address, Address> emulate(EmulatorHelper emuHelper, Address beg, Address end) {
		print("[*] Emulation started\n");
		printf("Beginning: %08x\n", beg.getOffset());
		printf("Ending: %08x\n", end.getOffset());
		emuHelper.writeRegister(emuHelper.getPCRegister(), beg.getOffset());
		List<AddressRange> prevMemRange = new ArrayList<AddressRange>();
		var tableEipMemMod = new HashMap<Address, Address>();
		
		while (monitor.isCancelled() == false) {
			var executionAddr = emuHelper.getExecutionAddress();
			if (executionAddr.getOffset() > end.getOffset()) {
				print("[*] Emulation finished\n");
				return tableEipMemMod;
			}
			
			boolean success;
			try {
				var eip = emuHelper.getExecutionAddress();
				success = emuHelper.step(monitor);
				var memsMod = emuHelper.getTrackedMemoryWriteSet();
				for (var mem : memsMod) {
					if (mem.getAddressSpace().getName().equalsIgnoreCase("ram") == true) {
						var included = false;
						for (var i = 0; i < prevMemRange.size(); i++) {
							var range = prevMemRange.get(i);
							// Test if ranges already in prevMemRange were updated
							if (range.getMinAddress().equals(mem.getMinAddress()) == false && range.getMaxAddress().equals(mem.getMaxAddress()) == true) {
								included = true;
								prevMemRange.set(i, mem);
								tableEipMemMod.put(mem.getMinAddress(), eip);
								break;
							} else if (range.getMinAddress().equals(mem.getMinAddress()) == true && range.getMaxAddress().equals(mem.getMaxAddress()) == false) {
								included = true;
								prevMemRange.set(i, mem);
								// add(0x1) is there to cover the cases where the binary writes more than 1 byte
								// example mov word [ebp + 0x5], 0x41
								// it will move the range and without the add, you will read a null byte
								tableEipMemMod.put(range.getMaxAddress().add(0x1), eip);
								break;
							} else if (range.getMinAddress().equals(mem.getMinAddress()) == true && range.getMaxAddress().equals(mem.getMaxAddress()) == true) {
								included = true;
								break;
							}
						}
						// If there is a new range, adds it to prevMemRange
						if (included == false) {
							prevMemRange.add(mem);
							tableEipMemMod.put(mem.getMinAddress(), eip);
						}
					}
				}
				
				if (success == false) {
					var error = emuHelper.getLastError();
					printf("[!] Error during emulation: %s\n", error);
					return tableEipMemMod;
				}
			} catch (CancelledException e) {
				e.printStackTrace();
				return tableEipMemMod;
			}
		}
		return tableEipMemMod;
	}
		
	@Override
	protected void run() throws Exception {
		var emuHelper = new EmulatorHelper(currentProgram);
		emuHelper.enableMemoryWriteTracking(true);
		emuHelper.writeRegister("ESP", 0x1000);
		emuHelper.writeRegister("EBP", 0x8000);
		var fnManager = currentProgram.getFunctionManager();
		var beg = currentSelection.getFirstRange().getMinAddress();
		var end = currentSelection.getLastRange().getMaxAddress();
		var function = fnManager.getFunctionContaining(beg);
		var fnVars = function.getLocalVariables();
		var mapFnVars = new HashMap<Integer, Variable>();
		
		for(var variable : fnVars) {
			var stackOffset = variable.getStackOffset();
			mapFnVars.put(stackOffset, variable);
		}
		
		var mems = emulate(emuHelper, beg, end);
		
		for (var addr : mems.keySet()) {
			var decrStr = "";
			var addrInstr = mems.get(addr);
			try {
				decrStr = emuHelper.readNullTerminatedString(addr, 0xffff);
			}
			catch (Exception e) {
				printf("[!] Error: %s\n", e.getMessage());
				continue;
			}
			printf("%s => %s => %s\n", addrInstr, addr, decrStr);
			var instruction = currentProgram.getListing().getInstructionAt(addrInstr);
			instruction.setComment(CodeUnit.EOL_COMMENT, decrStr);
			// try/catch => dirty. Should check if there are multiple operands and if there is a variable for that offset
			try {
				var toAddr = (int)instruction.getPrimaryReference(0).getToAddress().getOffset(); // cast to int otherwise doesn't work...
				var decrStrName = decrStr.strip().replaceAll(" ", "_");
				var name = "local_" + decrStrName;
				var variable = mapFnVars.get(toAddr);
				variable.setName(name, SourceType.USER_DEFINED);				
			} catch (Exception e) {
				continue;
			}

		}
		emuHelper.dispose();
	}
}
